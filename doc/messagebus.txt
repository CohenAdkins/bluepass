Message Bus
===========

The communication between the Bluepass frontend and backend takes place via a
message bus. The message bus runs over a socket and transfers JSON messages in
both directions. The protocol is loosely modeled after D-BUS model but it is
simpler.

Why not use D-BUS? Because we need to support platforms where D-BUS is not
available by default, and i don't want to be required to provide packages for
those platforms.

Message Exchanges
=================

1. Method calls

A method call is initiated by the following message::

  {
    'type': 'method_call',
    'serial': serial_number
    'sender': 'sender_name',
    'destination': 'destination_name',
    'member': 'method_name',
    'args': {}
  }

The sender/destination fields specify the connection names (see below) of the
sender and the destination. The method field specifies the method to call. The
serial field is an integer that needs to be unique for each message generated
by this sender. The 'args' field is an object containing keyword arguments to
the method call.

A peer will reply to a 'method_call' message with a single 'method_return'
message::

  {
    'type': 'method_return',
    'serial': serial_number',
    'reply_serial': reply_serial_number,
    'sender': 'sender_name',
    'destination': 'destination_name',
    'args': {}
  }

The significance of the fields is as for a "method_call" message. In addition
"reply_serial" field identifies the message this method_return is a reply to.

If there is an error, the 'error' message is returned instead of a
"method_return":

  {
    'type': 'error',
    'serial': serial_number',
    'reply_serial': reply_serial_number,
    'sender': 'sender_name',
    'destination': 'destination_name',
    'args': {
      'error_name': 'string_id',
      'error_message': 'textual error message'
    }
  }
 
The format is as for a "method_return" message with the addition that the
"args" field is guaranteed to have at least the "error_name" and the
"error_message" fields.

2. Signals

A signal is an asynchronous message that is not a reply to a method call but
instead signals an asynchronous condition that has happened::

  {
    'type': 'signal',
    'serial': serial_number',
    'sender': 'sender_name',
    'destination': 'destination_name',
    'member': 'signal_name',
    'args': {}
  }

The "destination" field for a signal is optional. If it is not set, it means
that the signal was sent to multiple connections on the message bus.


Connection Names
================

Each end point for the message bus connection has a name. The local name is
simply called the "name", and the remote name is called the "peer_name". The
local name is the peer name of the peer, and vice versa.

The server (= listening) side of a connection chooses a name before accepting
connections.  The name chosen by the Bluepass backend is 'backend'. The client
(= connecting) side get a unique name from the server side during
authentication.


Authentication
==============

A simple, mutual authentication scheme based on HMAC and a shared secret is
implemented. The protocol uses the "authenticate" message to establish the
authentication. No message types other than "authenticate" may travel over the
connection before a connection is authenticated.

The client starts the authentication handshake like this:

  {
    'type': 'authenticate',
    'method': 'hmac-magic-cookie-sha1',
    'nonce': 'random_string',
    'magic_cookie': 'cookie'
  }

The value of "magic_cookie" is the HMAC of the nonce under the shared secret
and using the SHA1 hash function.

The server will respond to the handshake with this message::

  {
    'type': 'authenticate',
    'method': 'hmac-magic-cookie-sha1',
    'nonce': 'random_string_2',
    'magic_cookie': 'cookie',
    'name': 'name of server',
    'peer_name': 'name assigned to client'
  }

The client then uses the 'nonce' and 'magic_cookie' to authenticate the server.
In case of an authentication error (at either side), the connection must be
closed.

The mechanism for sharing the secret is not specified. Currently the backend
and the frontend are always started up by the same master process, so that can
generate the secret and share it with both sides.
