#!/usr/bin/env python
#
# This file is part of Bluepass. Bluepass is Copyright (c) 2012-2013
# Geert Jansen.
#
# Bluepass is free software available under the GNU General Public License,
# version 3. See the file LICENSE distributed with this file for the exact
# licensing terms.
#
# This script reads the PKCS1 v2.1 test vectors as input and formats
# them in a way that is understood by our tests. The script understands
# test vectors for both encryption with OAEP and signatures with PSS.
#
# The input file that is needed for this program can be downloaded here:
# ftp://ftp.rsasecurity.com/pub/pkcs/pkcs-1/pkcs-1v2-1-vec.zip

import sys
import time

from pyasn1.codec.der import encoder
from pyasn1.type.univ import Sequence, Integer
from pyasn1.type.namedtype import NamedTypes, NamedType

if len(sys.argv) != 2:
    sys.stderr.write('Usage: %s <file>\n' % sys.argv[0])
    sys.exit(1)
fname = sys.argv[1]

tagmap = {
    'Message to be encrypted': 'PT', 'Seed': 'SEED', 'Encryption': 'CT',
    'Message to be signed': 'MSG', 'Salt': 'SALT', 'Signature': 'SIG'
}

s_sync, s_read_tag, s_read_value = range(3)
state = s_sync
records = []
for line in file(fname):
    line = line.rstrip()
    if state == s_sync:
        if not line:
            state = s_read_tag
    elif state == s_read_tag:
        if not line:
            continue
        if not line.startswith('#') or not line.endswith(':'):
            state = s_sync
            continue
        tag = line[2:-1]
        if tag in tagmap:
            tag = tagmap[tag]
        else:
            tag = tag.split()[-1]
        value = ''
        state = s_read_value
    elif state == s_read_value:
        if not line:
            records.append((tag, value))
            state = s_read_tag
            continue
        value += line.replace(' ', '')


vectors = []
for tag,value in records:
    if tag == 'n':
        key = {}
    if tag == 'PT':
        vector = key.copy()
    if tag in ('n', 'e', 'd', 'p', 'q', 'dP', 'dQ', 'qInv'):
        key[tag] = value
    else:
        vector[tag] = value
    if tag in ('CT', 'SIG'):
        vectors.append(vector)


class RSAPublicKey(Sequence):
    componentType = NamedTypes(
        NamedType('n', Integer()),
        NamedType('e', Integer()))

class RSAPrivateKey(Sequence):
    componentType = NamedTypes(
        NamedType('version', Integer()),
        NamedType('n', Integer()),
        NamedType('e', Integer()),
        NamedType('d', Integer()),
        NamedType('p', Integer()),
        NamedType('q', Integer()),
        NamedType('dP', Integer()),
        NamedType('dQ', Integer()),
        NamedType('qInv', Integer()))


for vector in vectors:
    pubkey = RSAPublicKey()
    for comp in ('n', 'e'):
        pubkey.setComponentByName(comp, int(vector[comp], 16))
    vector['PUBKEY'] = encoder.encode(pubkey).encode('hex')
    privkey = RSAPrivateKey()
    privkey.setComponentByName('version', 0)
    for comp in ('n', 'e', 'd', 'p', 'q', 'dP', 'dQ', 'qInv'):
        privkey.setComponentByName(comp, int(vector[comp], 16))
    vector['PRIVKEY'] = encoder.encode(privkey).encode('hex')


sys.stdout.write('# Generated by %s from %s on %s\n' % 
                 (sys.argv[0], sys.argv[1], time.ctime()))
for vector in vectors:
    sys.stdout.write('\n')
    for tag in ('PT', 'MSG', 'PUBKEY', 'PRIVKEY', 'SEED', 'CT', 'SALT', 'SIG'):
        if tag in vector:
            sys.stdout.write('%s=%s\n' % (tag, vector[tag]))
